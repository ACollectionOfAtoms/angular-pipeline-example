#!/usr/bin/env node

const tsMorph = require('ts-morph');
const childProcess = require('child_process');
const fs = require('fs');

function exec(command) {
  return childProcess
    .execSync(command)
    .toString()
    .trim();
}

function getProjectSemver() {
  return exec('jq -r .version package.json');
}

function getGitBranch() {
  return process.env.GIT_BRANCH || exec('git rev-parse --abbrev-ref HEAD');
}

function getGitCommitHash() {
  return process.env.GIT_COMMIT_SHA || exec('git rev-parse --verify HEAD');
}

function isGitDirty() {
  return process.env.GIT_IS_DIRTY || exec('git diff --quiet && echo "true" || echo "false"') === 'false';
}

function addVersionClassSourceFile(project, filename) {
  if (fs.existsSync(filename)) {
    fs.unlinkSync(filename);
  }

  sourceFile = project.createSourceFile(filename);

  const classDeclaration = sourceFile.addClass({
    name: 'BuildInfo',
    isExported: true
  });

  classDeclaration.addJsDoc(
    'NOTE: This class is generated by the project build tooling.'
  );

  classDeclaration.addProperty({
    name: 'semVer',
    isStatic: true,
    initializer: `'${getProjectSemver()}'`
  });

  classDeclaration.addProperty({
    name: 'gitCommitHash',
    isStatic: true,
    initializer: `'${getGitCommitHash()}'`
  });

  classDeclaration.addProperty({
    name: 'gitBranch',
    isStatic: true,
    initializer: `'${getGitBranch()}'`
  });

  classDeclaration.addProperty({
    name: 'isGitDirty',
    isStatic: true,
    initializer: `${isGitDirty()}`
  });
}

function main(versionFilename) {
  const project = new tsMorph.Project();

  addVersionClassSourceFile(project, versionFilename);

  project
    .getSourceFiles()
    .forEach(sourceFile => {
      sourceFile.formatText({
        indentSize: 2
      });
      sourceFile.saveSync();
      console.log(
        `The following class was written to: \n${sourceFile.getFilePath()}\n`
      );
      console.log(sourceFile.getFullText());
    });
}

if (require.main === module) {
  main(process.argv[2]);
}
